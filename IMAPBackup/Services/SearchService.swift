import Foundation
import PDFKit

/// Search result from file-based search
struct SearchResult: Identifiable {
    let id = UUID()
    let accountId: String
    let mailbox: String
    let messageId: String
    let sender: String
    let senderEmail: String
    let subject: String
    let date: Date
    let filePath: String
    let matchType: MatchType
    let snippet: String

    enum MatchType: String {
        case sender = "Sender"
        case subject = "Subject"
        case body = "Body"
        case attachment = "Attachment"
        case attachmentContent = "Attachment Content"
    }
}

/// Service for searching emails directly from .eml files
actor SearchService {
    private let backupLocation: URL

    init(backupLocation: URL) {
        self.backupLocation = backupLocation
    }

    // MARK: - Public API

    func open() throws {
        // No database to open - this is a no-op for compatibility
    }

    func close() {
        // No database to close - this is a no-op for compatibility
    }

    /// Get stats about indexed emails (counts .eml files)
    func getStats() throws -> (emailCount: Int, attachmentCount: Int) {
        let fileManager = FileManager.default
        var emailCount = 0

        guard fileManager.fileExists(atPath: backupLocation.path) else {
            return (0, 0)
        }

        let enumerator = fileManager.enumerator(
            at: backupLocation,
            includingPropertiesForKeys: [.isRegularFileKey],
            options: [.skipsHiddenFiles]
        )

        while let url = enumerator?.nextObject() as? URL {
            if url.pathExtension.lowercased() == "eml" {
                emailCount += 1
            }
        }

        return (emailCount, 0)
    }

    /// Search emails by query string
    func search(query: String, limit: Int = 100) throws -> [SearchResult] {
        let searchTerms = query.lowercased().components(separatedBy: .whitespaces).filter { !$0.isEmpty }
        guard !searchTerms.isEmpty else { return [] }

        var results: [SearchResult] = []
        let fileManager = FileManager.default

        guard fileManager.fileExists(atPath: backupLocation.path) else {
            return []
        }

        let enumerator = fileManager.enumerator(
            at: backupLocation,
            includingPropertiesForKeys: [.isRegularFileKey],
            options: [.skipsHiddenFiles]
        )

        while let url = enumerator?.nextObject() as? URL {
            guard url.pathExtension.lowercased() == "eml" else { continue }
            guard results.count < limit else { break }

            if let result = searchEmailFile(url: url, searchTerms: searchTerms) {
                results.append(result)
            }
        }

        // Sort by date descending
        return results.sorted { $0.date > $1.date }
    }

    /// Reindex all - this is a no-op for file-based search
    func reindexAll(progressCallback: @escaping (Int, Int) -> Void) throws {
        // Count files for progress
        let stats = try getStats()
        progressCallback(stats.emailCount, stats.emailCount)
    }

    // MARK: - Private Methods

    private func searchEmailFile(url: URL, searchTerms: [String]) -> SearchResult? {
        guard let content = try? String(contentsOf: url, encoding: .utf8) else {
            // Try other encodings
            guard let data = try? Data(contentsOf: url),
                  let content = String(data: data, encoding: .isoLatin1) else {
                return nil
            }
            return searchEmailContent(content: content, url: url, searchTerms: searchTerms)
        }
        return searchEmailContent(content: content, url: url, searchTerms: searchTerms)
    }

    private func searchEmailContent(content: String, url: URL, searchTerms: [String]) -> SearchResult? {
        let contentLower = content.lowercased()

        // Check if all search terms are present
        for term in searchTerms {
            if !contentLower.contains(term) {
                return nil
            }
        }

        // Parse email headers
        let (sender, senderEmail) = extractSender(from: content)
        let subject = extractHeader(named: "Subject", from: content) ?? "No Subject"
        let messageId = extractHeader(named: "Message-ID", from: content) ?? UUID().uuidString
        let date = extractDate(from: content)

        // Determine match type and create snippet
        let (matchType, snippet) = determineMatchType(content: content, contentLower: contentLower, searchTerms: searchTerms)

        // Extract account and mailbox from path
        let (accountId, mailbox) = extractPathInfo(from: url)

        return SearchResult(
            accountId: accountId,
            mailbox: mailbox,
            messageId: messageId,
            sender: sender,
            senderEmail: senderEmail,
            subject: subject,
            date: date,
            filePath: url.path,
            matchType: matchType,
            snippet: snippet
        )
    }

    private func extractSender(from content: String) -> (name: String, email: String) {
        guard let fromLine = extractHeader(named: "From", from: content) else {
            return ("Unknown", "")
        }

        // Parse "Name <email>" or just "email"
        if let match = fromLine.range(of: #"([^<]+)?<?([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})>?"#, options: .regularExpression) {
            let matched = String(fromLine[match])

            if let angleBracket = matched.firstIndex(of: "<") {
                let name = String(matched[..<angleBracket]).trimmingCharacters(in: .whitespaces)
                let emailStart = matched.index(after: angleBracket)
                if let emailEnd = matched.firstIndex(of: ">") {
                    let email = String(matched[emailStart..<emailEnd])
                    return (name.isEmpty ? email : name.replacingOccurrences(of: "\"", with: ""), email)
                }
            }

            return (matched, matched)
        }

        return (fromLine, fromLine)
    }

    private func extractHeader(named name: String, from content: String) -> String? {
        let pattern = "(?m)^\(name):\\s*(.+?)(?=\\r?\\n[^ \\t]|\\r?\\n\\r?\\n)"
        guard let regex = try? NSRegularExpression(pattern: pattern, options: [.caseInsensitive]),
              let match = regex.firstMatch(in: content, options: [], range: NSRange(content.startIndex..., in: content)),
              let range = Range(match.range(at: 1), in: content) else {
            // Try simpler single-line extraction
            let lines = content.components(separatedBy: .newlines)
            for line in lines {
                if line.lowercased().hasPrefix(name.lowercased() + ":") {
                    let value = String(line.dropFirst(name.count + 1)).trimmingCharacters(in: .whitespaces)
                    return decodeRFC2047(value)
                }
                // Stop at empty line (end of headers)
                if line.trimmingCharacters(in: .whitespaces).isEmpty {
                    break
                }
            }
            return nil
        }

        let value = String(content[range]).replacingOccurrences(of: "\r\n ", with: " ")
            .replacingOccurrences(of: "\n ", with: " ")
            .trimmingCharacters(in: .whitespacesAndNewlines)

        return decodeRFC2047(value)
    }

    private func extractDate(from content: String) -> Date {
        guard let dateString = extractHeader(named: "Date", from: content) else {
            return Date()
        }

        let formatters: [DateFormatter] = [
            {
                let df = DateFormatter()
                df.dateFormat = "EEE, dd MMM yyyy HH:mm:ss Z"
                df.locale = Locale(identifier: "en_US_POSIX")
                return df
            }(),
            {
                let df = DateFormatter()
                df.dateFormat = "dd MMM yyyy HH:mm:ss Z"
                df.locale = Locale(identifier: "en_US_POSIX")
                return df
            }(),
            {
                let df = DateFormatter()
                df.dateFormat = "EEE, dd MMM yyyy HH:mm:ss ZZZZZ"
                df.locale = Locale(identifier: "en_US_POSIX")
                return df
            }()
        ]

        for formatter in formatters {
            if let date = formatter.date(from: dateString) {
                return date
            }
        }

        return Date()
    }

    private func determineMatchType(content: String, contentLower: String, searchTerms: [String]) -> (SearchResult.MatchType, String) {
        let firstTerm = searchTerms[0]

        // Check sender
        if let from = extractHeader(named: "From", from: content)?.lowercased(), from.contains(firstTerm) {
            return (.sender, createSnippet(from: from, searchTerms: searchTerms))
        }

        // Check subject
        if let subject = extractHeader(named: "Subject", from: content)?.lowercased(), subject.contains(firstTerm) {
            return (.subject, createSnippet(from: subject, searchTerms: searchTerms))
        }

        // Check body
        let body = extractBodyText(from: content)
        if body.lowercased().contains(firstTerm) {
            return (.body, createSnippet(from: body, searchTerms: searchTerms))
        }

        // Default to body match
        return (.body, createSnippet(from: content, searchTerms: searchTerms))
    }

    private func extractBodyText(from content: String) -> String {
        // Find the body (after empty line in headers)
        let parts = content.components(separatedBy: "\r\n\r\n")
        if parts.count > 1 {
            let body = parts.dropFirst().joined(separator: "\r\n\r\n")
            return stripHTMLAndDecode(body)
        }

        let parts2 = content.components(separatedBy: "\n\n")
        if parts2.count > 1 {
            let body = parts2.dropFirst().joined(separator: "\n\n")
            return stripHTMLAndDecode(body)
        }

        return content
    }

    private func stripHTMLAndDecode(_ text: String) -> String {
        var result = text
        // Remove HTML tags
        result = result.replacingOccurrences(of: "<[^>]+>", with: " ", options: .regularExpression)
        // Decode HTML entities
        result = result.replacingOccurrences(of: "&nbsp;", with: " ")
        result = result.replacingOccurrences(of: "&amp;", with: "&")
        result = result.replacingOccurrences(of: "&lt;", with: "<")
        result = result.replacingOccurrences(of: "&gt;", with: ">")
        result = result.replacingOccurrences(of: "&quot;", with: "\"")
        // Decode quoted-printable common patterns
        result = result.replacingOccurrences(of: "=20", with: " ")
        result = result.replacingOccurrences(of: "=\r\n", with: "")
        result = result.replacingOccurrences(of: "=\n", with: "")
        // Clean up whitespace
        result = result.replacingOccurrences(of: "\\s+", with: " ", options: .regularExpression)
        return result.trimmingCharacters(in: .whitespacesAndNewlines)
    }

    private func createSnippet(from text: String, searchTerms: [String], maxLength: Int = 200) -> String {
        let textLower = text.lowercased()

        // Find position of first search term
        guard let firstTerm = searchTerms.first,
              let range = textLower.range(of: firstTerm) else {
            return String(text.prefix(maxLength))
        }

        // Get context around the match
        let matchStart = text.distance(from: text.startIndex, to: range.lowerBound)
        let snippetStart = max(0, matchStart - 50)
        let snippetEnd = min(text.count, matchStart + maxLength - 50)

        let startIndex = text.index(text.startIndex, offsetBy: snippetStart)
        let endIndex = text.index(text.startIndex, offsetBy: snippetEnd)

        var snippet = String(text[startIndex..<endIndex])

        // Add ellipsis if needed
        if snippetStart > 0 {
            snippet = "..." + snippet
        }
        if snippetEnd < text.count {
            snippet = snippet + "..."
        }

        // Highlight search terms
        for term in searchTerms {
            snippet = snippet.replacingOccurrences(
                of: term,
                with: "<mark>\(term)</mark>",
                options: .caseInsensitive
            )
        }

        return snippet
    }

    private func extractPathInfo(from url: URL) -> (accountId: String, mailbox: String) {
        let relativePath = url.path.replacingOccurrences(of: backupLocation.path + "/", with: "")
        let components = relativePath.components(separatedBy: "/")

        guard components.count >= 2 else {
            return ("Unknown", "Unknown")
        }

        let accountId = components[0]
        let mailbox = components.dropFirst().dropLast().joined(separator: "/")

        return (accountId, mailbox.isEmpty ? "INBOX" : mailbox)
    }

    private func decodeRFC2047(_ text: String) -> String {
        var result = text

        // Match =?charset?encoding?text?= pattern
        let pattern = #"=\?([^?]+)\?([BQbq])\?([^?]*)\?="#
        guard let regex = try? NSRegularExpression(pattern: pattern) else {
            return text
        }

        let matches = regex.matches(in: text, range: NSRange(text.startIndex..., in: text))

        for match in matches.reversed() {
            guard let fullRange = Range(match.range, in: text),
                  let charsetRange = Range(match.range(at: 1), in: text),
                  let encodingRange = Range(match.range(at: 2), in: text),
                  let encodedRange = Range(match.range(at: 3), in: text) else {
                continue
            }

            let charset = String(text[charsetRange])
            let encoding = String(text[encodingRange]).uppercased()
            let encoded = String(text[encodedRange])

            var decoded: String?

            if encoding == "B" {
                // Base64
                if let data = Data(base64Encoded: encoded) {
                    decoded = String(data: data, encoding: encodingFromCharset(charset)) ?? String(data: data, encoding: .utf8)
                }
            } else if encoding == "Q" {
                // Quoted-printable
                let qpDecoded = encoded.replacingOccurrences(of: "_", with: " ")
                    .replacingOccurrences(of: "=([0-9A-Fa-f]{2})", with: "", options: .regularExpression)
                decoded = qpDecoded
            }

            if let decoded = decoded {
                result.replaceSubrange(fullRange, with: decoded)
            }
        }

        return result
    }

    private func encodingFromCharset(_ charset: String) -> String.Encoding {
        switch charset.lowercased() {
        case "utf-8", "utf8": return .utf8
        case "iso-8859-1", "latin1": return .isoLatin1
        case "iso-8859-2", "latin2": return .isoLatin2
        case "us-ascii", "ascii": return .ascii
        case "windows-1252", "cp1252": return .windowsCP1252
        default: return .utf8
        }
    }
}
